// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Event types for different processing paths
///  Optimized to uint8 for memory efficiency (was uint32)
///  Determines downstream processing and storage routing
public enum schema_event_EventType: UInt8, Enum, Verifiable {
  public typealias T = UInt8
  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case unknown = 0
  case track = 1
  case identify = 2
  case group = 3
  case alias = 4
  case enrich = 5

  public static var max: schema_event_EventType { return .enrich }
  public static var min: schema_event_EventType { return .unknown }
}


///  Single event in the CDP system
///  Field IDs allow optimal memory layout and forward compatibility
///  Note: session_id (context_id) and message_id can be included in payload
///  if needed - testing through SDKs to determine if top-level fields are required
public struct schema_event_Event: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case timestamp = 4
    case eventType = 6
    case userId = 8
    case payload = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var timestamp: UInt64 { let o = _accessor.offset(VTOFFSET.timestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var eventType: schema_event_EventType { let o = _accessor.offset(VTOFFSET.eventType.v); return o == 0 ? .unknown : schema_event_EventType(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .unknown }
  public var hasUserId: Bool { let o = _accessor.offset(VTOFFSET.userId.v); return o == 0 ? false : true }
  public var userIdCount: Int32 { let o = _accessor.offset(VTOFFSET.userId.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func userId(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.userId.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var userId: [UInt8] { return _accessor.getVector(at: VTOFFSET.userId.v) ?? [] }
  public var hasPayload: Bool { let o = _accessor.offset(VTOFFSET.payload.v); return o == 0 ? false : true }
  public var payloadCount: Int32 { let o = _accessor.offset(VTOFFSET.payload.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func payload(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.payload.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var payload: [UInt8] { return _accessor.getVector(at: VTOFFSET.payload.v) ?? [] }
  public static func startEvent(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(timestamp: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timestamp, def: 0, at: VTOFFSET.timestamp.p) }
  public static func add(eventType: schema_event_EventType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: eventType.rawValue, def: 0, at: VTOFFSET.eventType.p) }
  public static func addVectorOf(userId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: userId, at: VTOFFSET.userId.p) }
  public static func addVectorOf(payload: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: payload, at: VTOFFSET.payload.p) }
  public static func endEvent(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEvent(
    _ fbb: inout FlatBufferBuilder,
    timestamp: UInt64 = 0,
    eventType: schema_event_EventType = .unknown,
    userIdVectorOffset userId: Offset = Offset(),
    payloadVectorOffset payload: Offset = Offset()
  ) -> Offset {
    let __start = schema_event_Event.startEvent(&fbb)
    schema_event_Event.add(timestamp: timestamp, &fbb)
    schema_event_Event.add(eventType: eventType, &fbb)
    schema_event_Event.addVectorOf(userId: userId, &fbb)
    schema_event_Event.addVectorOf(payload: payload, &fbb)
    return schema_event_Event.endEvent(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.timestamp.p, fieldName: "timestamp", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.eventType.p, fieldName: "eventType", required: false, type: schema_event_EventType.self)
    try _v.visit(field: VTOFFSET.userId.p, fieldName: "userId", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.payload.p, fieldName: "payload", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

///  Event data container (goes in Batch.data)
///  Contains batched events for efficient network transport
public struct schema_event_EventData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case events = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasEvents: Bool { let o = _accessor.offset(VTOFFSET.events.v); return o == 0 ? false : true }
  public var eventsCount: Int32 { let o = _accessor.offset(VTOFFSET.events.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func events(at index: Int32) -> schema_event_Event? { let o = _accessor.offset(VTOFFSET.events.v); return o == 0 ? nil : schema_event_Event(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startEventData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(events: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: events, at: VTOFFSET.events.p) }
  public static func endEventData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createEventData(
    _ fbb: inout FlatBufferBuilder,
    eventsVectorOffset events: Offset
  ) -> Offset {
    let __start = schema_event_EventData.startEventData(&fbb)
    schema_event_EventData.addVectorOf(events: events, &fbb)
    return schema_event_EventData.endEventData(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.events.p, fieldName: "events", required: true, type: ForwardOffset<Vector<ForwardOffset<schema_event_Event>, schema_event_Event>>.self)
    _v.finish()
  }
}

