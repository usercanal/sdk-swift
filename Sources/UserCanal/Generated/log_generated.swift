// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Log severity levels (RFC 5424 syslog standard + TRACE)
public enum schema_log_LogLevel: UInt8, Enum, Verifiable {
  public typealias T = UInt8
  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case emergency = 0
  case alert = 1
  case critical = 2
  case error = 3
  case warning = 4
  case notice = 5
  case info = 6
  case debug = 7
  case trace = 8

  public static var max: schema_log_LogLevel { return .trace }
  public static var min: schema_log_LogLevel { return .emergency }
}


///  Log-specific event types (optimized to uint8)
public enum schema_log_LogEventType: UInt8, Enum, Verifiable {
  public typealias T = UInt8
  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case unknown = 0
  case log = 1
  case enrich = 2

  public static var max: schema_log_LogEventType { return .enrich }
  public static var min: schema_log_LogEventType { return .unknown }
}


///  Single log entry - field order preserved for compatibility
public struct schema_log_LogEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case eventType = 4
    case sessionId = 6
    case level = 8
    case timestamp = 10
    case source = 12
    case service = 14
    case payload = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var eventType: schema_log_LogEventType { let o = _accessor.offset(VTOFFSET.eventType.v); return o == 0 ? .unknown : schema_log_LogEventType(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .unknown }
  public var hasSessionId: Bool { let o = _accessor.offset(VTOFFSET.sessionId.v); return o == 0 ? false : true }
  public var sessionIdCount: Int32 { let o = _accessor.offset(VTOFFSET.sessionId.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func sessionId(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.sessionId.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var sessionId: [UInt8] { return _accessor.getVector(at: VTOFFSET.sessionId.v) ?? [] }
  public var level: schema_log_LogLevel { let o = _accessor.offset(VTOFFSET.level.v); return o == 0 ? .emergency : schema_log_LogLevel(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .emergency }
  public var timestamp: UInt64 { let o = _accessor.offset(VTOFFSET.timestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var source: String? { let o = _accessor.offset(VTOFFSET.source.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sourceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.source.v) }
  public var service: String? { let o = _accessor.offset(VTOFFSET.service.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var serviceSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.service.v) }
  public var hasPayload: Bool { let o = _accessor.offset(VTOFFSET.payload.v); return o == 0 ? false : true }
  public var payloadCount: Int32 { let o = _accessor.offset(VTOFFSET.payload.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func payload(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.payload.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var payload: [UInt8] { return _accessor.getVector(at: VTOFFSET.payload.v) ?? [] }
  public static func startLogEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(eventType: schema_log_LogEventType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: eventType.rawValue, def: 0, at: VTOFFSET.eventType.p) }
  public static func addVectorOf(sessionId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sessionId, at: VTOFFSET.sessionId.p) }
  public static func add(level: schema_log_LogLevel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: level.rawValue, def: 0, at: VTOFFSET.level.p) }
  public static func add(timestamp: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timestamp, def: 0, at: VTOFFSET.timestamp.p) }
  public static func add(source: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: source, at: VTOFFSET.source.p) }
  public static func add(service: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: service, at: VTOFFSET.service.p) }
  public static func addVectorOf(payload: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: payload, at: VTOFFSET.payload.p) }
  public static func endLogEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLogEntry(
    _ fbb: inout FlatBufferBuilder,
    eventType: schema_log_LogEventType = .unknown,
    sessionIdVectorOffset sessionId: Offset = Offset(),
    level: schema_log_LogLevel = .emergency,
    timestamp: UInt64 = 0,
    sourceOffset source: Offset = Offset(),
    serviceOffset service: Offset = Offset(),
    payloadVectorOffset payload: Offset = Offset()
  ) -> Offset {
    let __start = schema_log_LogEntry.startLogEntry(&fbb)
    schema_log_LogEntry.add(eventType: eventType, &fbb)
    schema_log_LogEntry.addVectorOf(sessionId: sessionId, &fbb)
    schema_log_LogEntry.add(level: level, &fbb)
    schema_log_LogEntry.add(timestamp: timestamp, &fbb)
    schema_log_LogEntry.add(source: source, &fbb)
    schema_log_LogEntry.add(service: service, &fbb)
    schema_log_LogEntry.addVectorOf(payload: payload, &fbb)
    return schema_log_LogEntry.endLogEntry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.eventType.p, fieldName: "eventType", required: false, type: schema_log_LogEventType.self)
    try _v.visit(field: VTOFFSET.sessionId.p, fieldName: "sessionId", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.level.p, fieldName: "level", required: false, type: schema_log_LogLevel.self)
    try _v.visit(field: VTOFFSET.timestamp.p, fieldName: "timestamp", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.source.p, fieldName: "source", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.service.p, fieldName: "service", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.payload.p, fieldName: "payload", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

public struct schema_log_LogData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case logs = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasLogs: Bool { let o = _accessor.offset(VTOFFSET.logs.v); return o == 0 ? false : true }
  public var logsCount: Int32 { let o = _accessor.offset(VTOFFSET.logs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func logs(at index: Int32) -> schema_log_LogEntry? { let o = _accessor.offset(VTOFFSET.logs.v); return o == 0 ? nil : schema_log_LogEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startLogData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(logs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: logs, at: VTOFFSET.logs.p) }
  public static func endLogData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createLogData(
    _ fbb: inout FlatBufferBuilder,
    logsVectorOffset logs: Offset
  ) -> Offset {
    let __start = schema_log_LogData.startLogData(&fbb)
    schema_log_LogData.addVectorOf(logs: logs, &fbb)
    return schema_log_LogData.endLogData(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.logs.p, fieldName: "logs", required: true, type: ForwardOffset<Vector<ForwardOffset<schema_log_LogEntry>, schema_log_LogEntry>>.self)
    _v.finish()
  }
}

