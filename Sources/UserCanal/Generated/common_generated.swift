// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Schema types for routing and streaming
///  Used by the collector to determine how to process incoming data
public enum schema_common_SchemaType: UInt8, Enum, Verifiable {
  public typealias T = UInt8
  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case unknown = 0
  case event = 1
  case log = 2
  case metric = 3
  case inventory = 4

  public static var max: schema_common_SchemaType { return .inventory }
  public static var min: schema_common_SchemaType { return .unknown }
}


///  Standard batch structure for all data types
///  This is the top-level container that wraps all schema-specific data
///  Field IDs ensure forward compatibility and allow optimal field ordering
public struct schema_common_Batch: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_2_10() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case apiKey = 4
    case batchId = 6
    case schemaType = 8
    case data = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasApiKey: Bool { let o = _accessor.offset(VTOFFSET.apiKey.v); return o == 0 ? false : true }
  public var apiKeyCount: Int32 { let o = _accessor.offset(VTOFFSET.apiKey.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func apiKey(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.apiKey.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var apiKey: [UInt8] { return _accessor.getVector(at: VTOFFSET.apiKey.v) ?? [] }
  public var batchId: UInt64 { let o = _accessor.offset(VTOFFSET.batchId.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var schemaType: schema_common_SchemaType { let o = _accessor.offset(VTOFFSET.schemaType.v); return o == 0 ? .unknown : schema_common_SchemaType(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .unknown }
  public var hasData: Bool { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? false : true }
  public var dataCount: Int32 { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func data(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var data: [UInt8] { return _accessor.getVector(at: VTOFFSET.data.v) ?? [] }
  public static func startBatch(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func addVectorOf(apiKey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: apiKey, at: VTOFFSET.apiKey.p) }
  public static func add(batchId: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: batchId, def: 0, at: VTOFFSET.batchId.p) }
  public static func add(schemaType: schema_common_SchemaType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: schemaType.rawValue, def: 0, at: VTOFFSET.schemaType.p) }
  public static func addVectorOf(data: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: data, at: VTOFFSET.data.p) }
  public static func endBatch(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 10]); return end }
  public static func createBatch(
    _ fbb: inout FlatBufferBuilder,
    apiKeyVectorOffset apiKey: Offset,
    batchId: UInt64 = 0,
    schemaType: schema_common_SchemaType = .unknown,
    dataVectorOffset data: Offset
  ) -> Offset {
    let __start = schema_common_Batch.startBatch(&fbb)
    schema_common_Batch.addVectorOf(apiKey: apiKey, &fbb)
    schema_common_Batch.add(batchId: batchId, &fbb)
    schema_common_Batch.add(schemaType: schemaType, &fbb)
    schema_common_Batch.addVectorOf(data: data, &fbb)
    return schema_common_Batch.endBatch(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.apiKey.p, fieldName: "apiKey", required: true, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.batchId.p, fieldName: "batchId", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.schemaType.p, fieldName: "schemaType", required: false, type: schema_common_SchemaType.self)
    try _v.visit(field: VTOFFSET.data.p, fieldName: "data", required: true, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

